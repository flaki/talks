<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="./effect/effect.css">
</head>
<body>
    <main>
        <section id=opening class=no-effect>
            <img src="./assets/nuka-fullsize.jpg" alt="JSConf Korea branded Nuka Cola bottle" style="
                width: 100%;
                margin-bottom: -3rem;
            " />
            <h4>
                A WebAssembly Field Guide | Flaki, JSConf Korea 2019
            </h4>
            <pre class="notes">
                Content Warning: slides contain some mild flashing and visual glitching.
            </pre>
        </section>
        <section id=intro>
            <img src="./assets/nuka-jsconf.svg" alt="A stylized JSConf Korea branded Nuka Cola bottle" style="
                width: 100%;
                margin-bottom: -3rem;
            " />
            <h4>
                presents
            </h4>
        </section>
        <section id=welcome>
            <img src="./assets/welcome2.svg" alt="A giant book with a WebAssembly logo is held up triumphantly by Boy, the story's main protagonist" />
            <h2>
                    Welcome to Vault 6D-73-61!
            </h2>
            <pre class="notes">
                You've spent your whole life underground, always curious and fascinated by the gently humming machines around you, doing their jobs to sustain your community. Whatever caused the big calamity that forced your ancestors decades ago was in receding, people recently started wandering outside the heavy vault doors, exploring your desolate surroundings.
                
                The re-established connection to other settlements came handy when you managed to barter a bulky operating manual and started discovering the depths of the technology that is at the beating heart of your underground habitat. As a newly appointed Chief Vault Technician are tasked to use this knowledge to improve the life of your community, and you have every intention in doing so...
            </pre>
        </section>
        <section id=aboutme-flaki>
            <img src="./assets/pip-flaki.svg" alt="A Fallout-style PIP boy device, with a cartoon tiger on the display, representing Istvan's Twitter avatar" />
            <h2>
                Istvan Szmozsanszky, a.k.a. Flaki<br>
                @slsoftworks
            </h2>
            <pre class="notes">
                My name is Istvan Szmozsanszky (now you know why I just “Flaki”).
                I’m a freelance web developer - originally from Budapest, Hungary but I live in Estonia.
                I've spent quite some time in Asia in the past few years but this is my first time in Korea, not counting that one transfer in Incheon airport.
            </pre>
        </section>
        <section id=aboutme-ts>
                <img src="./assets/pip-ts.svg" alt="A Fallout-style PIP boy device, with a the Mozilla Tech Speakers logo on the display" />
                <h2>
                Mozilla Tech Speakers<br>
                @mozTechSpeakers
            </h2>
            <pre class="notes">
                I’m a Mozilla Tech Speaker - TechSpeakers is a program by Mozilla to support its community members teaching and speaking at conferences about open web technologies and the open web in general.
            </pre>
        </section>
        <section id=aboutme-moz>
                <img src="./assets/pip-clean.svg" alt="A Fallout-style PIP boy device, with a the Mozilla Hacks dino logo on the display" />
                <h2>
                Developer Relations @ Mozilla<br>
                @mozhacks
            </h2>
            <pre class="notes">
                I work with Mozilla’s DevRel Team where I help steer their developer community efforts (including the Tech Speakers program) & evangelizing open web technologies, especially some of the bleeding edge stuff like WebAssembly, service workers and a systems programming language called Rust.
                
                (if you cannot imagine what could a systems programming language have to do with the open web, hold on to that thought, we’ll get there!).
            </pre>
        </section>

        <section id=aboutme-moz>
            <img src="./assets/pip-clean.svg" alt="A Fallout-style PIP boy device, with a the WebAssembly logo on the display" />
                <h2>
                Join the WebAssembly community!<br>
                webassembly.org
            </h2>
            <pre class="notes">
                I have been following closely the developments around WebAssembly and related technologies for a few years now, and currently also participate in the WebAssembly Community Group that is driving the evolution of the specification and the expansion of WebAssembly’s featureset... and you could be, too!
                
                You don’t have to be a compiler engineer, or need to work at a big influential company to do this! The Community Group operates under the supervision of W3C, but is actually open to participation for anyone interested.

                Go to webassembly.org and visit the Community page to learn about the many ways you could contribute to the work of the community group.
            </pre>
        </section>

        <section id=aboutme-mozwa>
            <img src="./assets/pip-mozwa.svg" alt="A Fallout-style PIP boy device, with a the WebAssembly logo on the display, but the W and A characters are replaced with the Mozilla dino" />
            <h2>
                Shape WebAssembly @ Mozilla Advanced Development
            </h2>
            <pre class="notes">
                In this talk I will mention some of the many ways Mozilla (and people working at Mozilla) contributed to the creation & evolution of WebAssembly. While I haven’t been involved in this effort, there is now an entire dedicated team at Mozilla, working on the bleeding edge of web technologies, shaping WebAssembly's future.
                
                If you would be interested in being part of this work find me later and I will be happy to connect you with the right people.
            </pre>
        </section>

        <section id="play">
            <img src="./assets/tinker.png" alt="Boy, pictured playing with a toy locomotive set" />
            <h2>
                Explore, Tinker, Experiment!
            </h2>
            <pre class="notes">
                Before we dive in: this talk is not intended to teach you how to use/code/generate WebAssembly.
                
                There is great documentation, online code playgrounds, tutorials and blogposts a-plenty that can help you once you’ve decided to get your hands dirty… this talk will focus more on how will you get there. The intention is to offer a better understanding for anyone why should they care (or maybe even, if they should care at all) about WebAssembly and help you out by providing pointers where to look for more information should you decide to dive in.
            </pre>
        </section>

        <section id=disclaimer>
            <img src="./assets/disclaimer.png" alt="DVD-style warning fineprint reads: Warning! Due to the nature of the technologies discussed herewithin there is always fair chance for any factually specific information regarding the technologies as they are implemented to be outdated by the time this work is consumed. This is inevitable despite the Author’s best efforts, and thus all details presented ought to be taken with a grain of salt and perhaps even a tiny dash of skepticism. All depicted events & characters portrayed in this presentation are a work of fiction and exist solely in a computer’s digital imagination, with high probability amongst a kettle of electric sheep. Furthermore any perceived similarity or resemblance to actual triple-A multimedia entertainment titles could merely be coincidental." />
            <h2>Disclaimer</h2>

            <pre class="notes">
                “Due to the nature of the technologies discussed herewithin there is always fair chance for any factually specific information regarding…” yada-yada, people never read these disclaimers anyway, right?
                
                The gist of it is: I’m going to be talking about highly volatile, work-in-progress technologies that might change anytime, significantly, so always do your research first before taking any of this into production!

                Now with that out of the way, let us get back to our favorite Vault Technician who’s about to learn an invaluable lesson…
            </pre>
        </section>

        <section id=act1>
            <img src="./assets/explore.png" alt="A book with a WebAssembly logo on its cover flying out of a room out into a scarcely lit corridor" />
            <h2>
                Act I.<br>
                History Lesson
            </h2>

            <pre class="notes">
                Couple hundred pages into your newly acquired operating manual you still seem to be stuck with historical tropes from an era where horse-drawn carriages roamed the streets. All this time, there is not a single bit of userful & hands-on information to be found on any of your vault’s systems. What a waste of time! In your sudden fit of rage you angrily toss the manual onto the corridor, flying right past one one elderly fellow vault dweller.
                
                You apologise profusely, explaining the situation, but the old man just laughs, his reply imparts a lifetime of wisdom: “Oh dear… Actually, history provides the single most precious kind of knowledge amongst all -- there are innumerable, invaluable lessons to be learned from the context exposed by past history…”.                    
            </pre>
        </section>

        <section id=history-context>
            <img src="./assets/rome.svg" alt="Boy dressed as a roman warrior with the Colosseum in the backdrop" />
            <h2>History provides Context</h2>

            <pre class="notes">
                Skepticism towards WebAssembly may often be rooted in the fact that few are familiar with the technology’s evolution, influences or goals -- its history, for short.
                
                Of course, we can’t really expect all developers to know about the long journey that led to WebAssembly’s creation, but I’ll take a stab at highlighting few of the main motivators -- real issues of the web platform and the solutions WebAssembly aims to provide.  
            </pre>
        </section>

        <section id=what-is-webassembly>
            <img src="./assets/whatis.svg" alt="" />
            <h2>
                But wait...<br>
                What is this WebAssembly again?
            </h2>
            <pre class="notes">
                WebAssembly allows code that was written in a wide variety of programming languages to be run securely on the web.
                
                The original source code of a supporting programming language is compiled into a size- & execution speed-efficient binary format that can be executed safely and at close-to-native speeds inside the web browser.
            </pre>
        </section>

        <section id=what-is-fast>
            <img src="./assets/whatis.svg" alt="" />
            <h2>
                But wait...<br>
                What is this WebAssembly again?
            </h2>
            <pre class="notes">
                “Close-to-native speed” here refers to the fact that execution speed of WebAssembly-compiled binaries, in many cases today are able to approach the performance of the same source code when it’s compiled to the native executable format of any given platform.
            </pre>
        </section>

        <section id=what-is-safe>
            <img src="./assets/whatis.svg" alt="" />
            <h2>
                But wait...<br>
                What is this WebAssembly again?
            </h2>
            <pre class="notes">
                “Safe execution”, on the other hand refers to various ways how during execution of WebAssembly code certain privacy and security guarantees are strictly enforced, so running third-party code on the user’s machine remains safe, robust and - in the case of the web - respecting the origin’s policies that have served it.
            </pre>
        </section>

        <section id=timeline>
            <img src="./assets/asm-wasm.svg" alt="A stone-age cartoon car representing the pre-Webassembly times next to an Asm.js and WebAssembly logo illustrating the timeline leading up to WebAssembly's inception" />
            <h2>
                A Whirlwind Tour of Compile to Web
            </h2>
            <pre class="notes">
                Before 2012, that was basically the primordial period. You know, jQuery, AJAX... Except JavaScript has been steadily increasing in speed for half a decade now. The war of JavaScript engines toughened them up all.

                Asm.js debuted in 2013, it was created as an easy-to-optimize JavaScript subset that compilers and tools could directly target to generate code that will run in the browser. Browser JS engines had specific optimizations for this code, in supporting browsers it was even possible to compile games and 3D engines, verbatim, and run them in the browser at good speeds. The game industry certainly noticed.
                
                WebAssembly was released in 2015, all four browsers shipped support in a few-months-wide time window.
                
                But worry not, I wasn’t planning to bore you with an *actual* history lesson, I think it’s much more interesting to see take some of the WebAssembly's key traits and look into it how they came to be.   
            </pre>
        </section>

        <section id=augment-wasm>
            <img src="./assets/brick.png" alt="" />
            <h2>
                Augment - not obsolete
            </h2>
            <pre class="notes">
                WebAssembly has been built on the core principle that can be summarized as “augment, not obsolete”, focusing on seamless integration as it strives to extend & complement the existing web platform capabilities, rather than trying to compete with them.

                “Can’t break the web” is a widely-known principle in the web standards community. It is one of the primary constraints observed when TC39, the committee tasked with evolving the JavaScript language considers extending the ECMAScript specification. WebAssembly takes these same ideals to ensure it can be an integral, cooperative part of the ecosystem.
            </pre>
        </section>

        <section id=augment-platform-access>
            <img src="./assets/brick.png" alt="" />
            <h2>
                The principle of least privilege at work
            </h2>
            <pre class="notes">
                WebAssembly modules are largely inert without the embedder’s cooperation. One of the original embedders is JavaScript itself (in the browser). In this case one could say (with some simplification) that “with WebAssembly, you will only be able to do whatever your JavaScript could already do -- just potentially faster”. API calls that need to access the environment still need to go through the JS runtime -- as a result most of today’s use cases are characterized by “data crunching” on easily separable, performance-sensitive tasks.

                After the embedder “instantiates” a Wasm module, allocating memory for it and passing in all other resources it needs, the live module itself has very limited access to its environment (also known as "The Principle of Least Privilege"). The module may have hooks into system APIs and other JS bindings (that were passed in during instantiation), or it may request services, such as more memory via the JS API, but the embedding environment has the authority to deny any such request, leaving WebAssembly highly dependent on its embedder’s cooperation.
                
                There are, in fact, many in-flight features and extensions to the standard that are working towards further deepening the integration between the executing Wasm code and the embedder.
            </pre>
        </section>

        <section id=augment-asmjs>
            <img src="./assets/brick.png" alt="" />
            <h2>
                Evolution over revolution
            </h2>
            <pre class="notes">
                +
                This cooperative, complementary relationship actually predates WebAssembly. Asm.js was “still practically JavaScript” but its brilliance lies in the fact that the changes required for supporting it were so minimal that all large browsers wanted in on it. The Asm.js feature set wasn’t only easy to implement in JavaScript engines, but was a straightforward enough set of instructions for tooling (primarily compilers) to target, too.
                
                Soon enough, all leading browsers have shipped support for Asm.js optimizations in their engines, almost simultaneously. This cooperation of browser vendors outlived Asm.js and following its success, the people who worked on Asm.js started exploring potential solutions to fix some of Asm.js’s inherent shortcomings.
                
                The evolution of Asm.js & WebAssembly could easily fill its very own talk, so I won’t go into further details. I’ll also link to some great resources at the end if you want to learn more.
            </pre>
        </section>

        <section id=simple-mvp>
            <img src="./assets/simple.svg" alt="Picture of the Pokemon Ditto" />
            <h2>
                Simplicity<br>
                via neccessity...
            </h2>
            <pre class="notes">
                For a casual observer, WebAssembly is often perceived as “simple”, usually refering to its highly constrained feature set.
                
                After shipping Asm.js it became clear some of its shortcomings were not fixable without breaking the web, or a departure from the existing architecture, so this work spawned many different ideas and prototypes, all of which eventually converged into a minimal set of features that we call the WebAssembly MVP today. While browser vendors working closely together on Asm.js have paved a way for a cooperation strong enough to make a sweeping change as WebAssembly possible, but even so, the group had to focus on laying the groundwork for WebAssembly (and not get bogged down with advanced features). This work called the “WebAssembly MVP”, a Minimum Viable WebAssembly, that allowed for robust and future-proof foundations and an extensible framework, even in this diverse, cross-industry setting, while allowing the more contentious issues to bake for some more time, and incorporate some of the early feedback as it would be trickling in.

                This made WebAssembly constantly evolve, as the community group designs additional enhancements based on both implementer- and end-user feedback. There are 10+ proposals currently in flight, in various stages of completion even now.
                
                While that's all true, looking past the resource constraints of the standardization work, WebAssembly’s overall simplicity is also...
            </pre>
        </section>

        <section id=simple-by-design>
            <img src="" alt="Two excerpts from the WebAssembly specification: &quot;(redacted) every thread (redacted) either runs forever, traps, or terminates with a result that has the expected type.&quot; and &quot;(redacted) no computation (redacted) can “crash” or otherwise (mis)behave in ways not covered by the execution semantics given in this specification.&quot;" />
            <h2>
                ...or Simplicity<br>
                as a defining feature
            </h2>
            <pre class="notes">
                ...a deliberate design choice.

                The entire specification is around a hundred pages, the instruction set and the formal description of the Wasm runtime fits on a single page.

                <blockquote>
                    [...] every thread [...] either runs forever, traps, or terminates with a result that has the expected type.
                </blockquote>
                <blockquote>
                    [...] no computation [...] can “crash” or otherwise (mis)behave in ways not covered by the execution semantics given in this specification.
                </blockquote>
                
                These are quotes from the specification. This simplicity awards WebAssembly not only robustness and less complex & less error-prone runtime that’s easier and faster to implement, but also the fact that these runtimes could generate reasonably and consistently fast code across all the platforms WebAssembly can target.
                
                This property -- the safe & secure execution at consistently fast, close-to-native speeds on all target platforms -- is already hinting towards usecases beyond the web, but let us not get ahead of ourselves, and talk about what (creators on) the web have to gain first.
            </pre>
        </section>
    
        
        <section id=act2>
            <img src="./assets/chest.png" alt="" />
            <h2>
                Act II.<br>
                Unearthing the Buried Treasure
            </h2>

            <pre class="notes">
            </pre>
        </section>
        
        <section id=why-wasm>
            <img src="./assets/fits.png" alt="" />
            <h2>
                Why should you Wasm?
            </h2>

            <pre class="notes">
                Often it’s not easy to immediately the see the benefit of a technology for one’s own usecases—but this doesn't mean it doesn't have any. Finding the ideal use case often takes time, and cannot happen without exploratory research and experimentation. Industry testimonials that report significant gains from making use of WebAssembly almost never fail to mention the winding road they have embarked on before the true benefits of the technology started shining through.
                
                Wasm is a really versatile technology (it is a turing-complete stack machine, after all) which means the possibilities are near limitless, but does not come without tradeoffs. Prototyping and measuring real user benefit , change in engineering productivity, product complexity etc. is crucial for making sure the right balance is struck in these tradeoffs.
            </pre>
        </section>

        <section id=>
            <img src="./assets/pkg.png" alt="" />
            <h2>
                WebAssembly Monoliths
            </h2>

            <pre class="notes">
                One of the first (and most mature) tools used in the ecosystem is Emscripten. Emscripten is the same age as the compile-to-JS ecosystem, it was born with and co-evolved alongside Asm.js, and when WebAssembly rolled around Emscripten was one of the first tools supporting it as an output/target format.

                Compiling large pre-existing code, libraries, or even whole apps—sometimes millions of lines of code— is not the most frequent web usecase, I’ll admit. Not everyone here works on triple-A game titles that need to run in a browser without plugins, or is trying to transition a 20-year-old desktop codebase to run in a browser. Also, often these compiled bundles ended up being tens or even hundreds of megabytes, that’s a very scary figure, even in this day & age of generally bloated websites.
                
                All this is to say, that this era has certainly found(ed) an enthusiastic niche for the technology, but remained far from becoming “mainstream”...
            </pre>
        </section>

        <section id=>
            <img src="./assets/pkg.png" alt="" />
            <h2>
                WebAssembly as a drop-in replacement
            </h2>

            <pre class="notes">
                ...well, but even for those not writing their own games and desktop-class apps, Emscripten was still useful. One could write a small(-ish) module in a low-level language, like C/C++, compile it and use it in one’s webapp to surgically replace raw performance-sensitive parts, or use it to target the web as one of the platforms. One would need to be able to write code in a low-level language, as well as write JavaScript glue code to the custom modules (thus, not making these libraries/modules the most portable & reusable pieces of code ever writtten), but it worked.

                Emscripten isn’t the only way, either—Rust was one of the first low-level systems languages that not only added built-in WebAssembly target support, but doubled down in supporting the Wasm as a first-class citizen.
                Stellar docs, sophisticated tooling and an extensive library of “crates” (third-party modules) that could be imported and re-used in one’s custom code made Rust an ideal choice it easier to avoid reinventing the proverbial wheel… Of course, not everyone can (or wants) to code in low-level languages just to get work done. AssemblyScript provides a TypeScript-like language to allow for creation of Wasm modules in a more familial language to JS devs, that can further lower the barrier of entry for Wasm module creators.
            </pre>
        </section>

        <section id=>
            <img src="./assets/surma.png" alt="You do not need to understand all of this to be a good web developer or even to make good use of WebAssembly." />
            <h2>
                Surma: Compiling C to WebAssembly without Emscripten
            </h2>

            <pre class="notes">
                <a href="https://dassur.ma/things/c-to-webassembly/">dassur.ma/things/c-to-webassembly/</a>

                Surma in the quoted post explains one does not need to resort to using bespoke tooling just to be able to generate a WebAssembly module and use it in one's projects. And surely, Emscripten or using precompiled Wasm distributions of useful libraries will go a long way. With things like AssemblyScript (a source language for WebAssembly based on TypeScript, intended to be easy to pick up ) and more and more languages adding direct support for WebAssembly, the purpose-built components will also thrive.

                But even so it's hard to imagine that authoring WebAssembly modules will become a mainstream task, undertaken by the majority of web developers.
                
                And that’s perfectly fine.
                
                It shouldn’t be! The good news is: one does not need to know how to create WebAssembly modules to be able to benefit from the new technology’s ecosystem effects!
            </pre>
        </section>

        <section id=>
            <img src="./assets/pkg.png" alt="" />
            <h2>
                WebAssembly as integral ecosystem component
            </h2>

            <pre class="notes">
                Some of the more recent proposals that are currently being worked on (such as the Interface Types (nee WebIDL bindings) proposal or the ES Modules Interop work) promise to integrate WebAssembly modules even more seamlessly into the existing ecosystem. In the future one might import a module using their favorite package manager and it might be using WebAssembly under the hood without the user being aware of the fact in the first place!
                
                Also, even if one’s production code won’t end up using WebAssembly, one might still benefit from WebAssembly via build tooling and other adjacent tools utilizing WebAssembly in their own products. Webpack has been one of the early experimenters with WebAssembly, exploring how it could improve build times in the future with promising results…
                
                With recent announcements around Interface Types by the Mozilla Wasm team, this interoperability paradise might be closer than you’d think, but let us have a glance at the slightly-further-out potential of WebAssembly...
            </pre>
        </section>

        <section id=act3>
            <img src="./assets/act3.png" alt="" />
            <h2>
                Act III.<br>
                The Weird, the Wonderful and the Unexpected
            </h2>

            <pre class="notes">
            </pre>
        </section>


        <section id=>
            <img src="./assets/languagesupport.svg" alt="The logo of the Haskell programming language" />
            <h2>
               The lack of language choice is an accessibility issue
            </h2>

            <pre class="notes">
                Choose whichever language you feel comfortable with to talk to the browser

                It’s never easy to “predict the future” of a nascent ecosystem—and WebAssembly is no different, certainly very early in its evolution, but already with plenty of future potential and promising experiments.
                
                Some of the currently discussed post-MVP features, such as GC integration, Web IDL integration, Threading & Tail Calls to name a few will make it possible for more languages (and more exotic ones, that is languages and programming paradigms very from what JavaScript looks like today) to target & interoperate with the web. This of course nothing new, we live in an age of Babel, TypeScript, Elm, Reason… But WebAssembly will make this process even better. Way better.
                
                This is not only important form a technological standpoint, but from Increasing the diversity & accessibility of developing for the web. Allowing people to use whatever language they feel comfortable with (rather than mandating one particular one) on the Web can have serious implications and ripple effects on the platform’s future.
            </pre>
        </section>

        <section id=>
            <img src="./assets/vass.png" alt="Because of every language wanting to run in the browser now suddenly you have a common low-level layer they all support…" />
            <h2>
                Growing Ecosystem Effects
            </h2>

            <pre class="notes">
                https://www.youtube.com/watch?v=rZEQNH27y-k

                Tibor Vass in the above quote mentions what is often observed: the Web Platform's gravity have given WebAssembly adoption an immense boost. But not all usecases necessarily need to involve the browser. The browser may be a vehicle to popularize WebAssembly, but that generated code can later run in any WebAssembly-compatible runtime.
            </pre>
        </section>

        <section id=>
            <img src="./assets/newfrontiers.png" alt="" />
            <h2>
                Why restrict ourselves to the browser?
            </h2>

            <pre class="notes">
                Would it be possible to take some of the values of safe and secure sandboxing in the browser beyond the web with WebAssembly? Would it be possible to still provide enough power and flexibility required by the other all other use cases? These are the questions that are being explored in the sister-specification of the WebAssembly System Interface, or WASI for short. What would it take to take WebAssembly into less restricted environments, providing more capabilities but still retaining most of the safety guarantees that make WebAssembly so unique.
            </pre>
        </section>

        <section id=wasi class=no-effect>
            <img src="./assets/wasi.png" alt="" />
            <h2>
                ...we are not so different, after all.
            </h2>

            <pre class="notes">
                https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/

                WASI is another tremendous effort in re-imagining certain aspects of computing that we have grown to accept as given. The proposal, initially offered by Mozilla but now worked on in the open in its own WebAssembly subgroup has the potential to extend WebAssembly's usefulness in a standardized way across all non-web platforms and usecases.

                The Web, Embedded (microcontrollers), Cloud (edge computing)? At the end of the day, we might realize, that what seem vastly different usecases, are actually closer to each other than we think. Code size constraints of the web (reducing transmission time) correspond to requirements on edge computing servers (transmission/syncing & storage limitations) as well as microcontrollers (storage).
                
                What we realize is not only WebAssembly is making its way to all of these platforms, but motivates the creation of small, self-contained libraries on the source code's side, transitively enriching the web ecosystem.

                You can learn more about WASI and its potential in Mozilla's Hacks blog thanks to Lin Clark's amazing and accessible cartoon deep-dives (I will share the links in the slides' resources section)
            </pre>
        </section>

        <section id=nasser class=no-effect>
            <img src="./assets/ra.svg" alt="The Korean characters &quot;영어로 말할 수 있어요?&quot; presented in the colors of the rainbow." />
            <h4></h4>

            <pre class="notes">
                And when we’ve done all that, why stop there?
                What if anyone could use their language of your choice to program—but we were not talking about programming languages here, but human languages!
                
                What if learning programming didn't have to start with learning the latin alphabet and all those "if"-s and "for"-s?
                
                Ramsey Nasser’s amazing thought-provoking talk from Deconstruct conference earlier this year explored how a programming language/paradigm that was purely language-agnostic could look like. His design prototype was building on WebAssembly as the underlying machine-readable code storage, with language-specific metadata layered above to give everyone the chance to learn to code in their own native tongue!
                
                https://twitter.com/ra/status/1153657792730927106
                https://twitter.com/ra/status/1143675211000270849
                https://twitter.com/hillelogram/status/1149443171274780672
                
                As said, WebAssembly’s potential is seemingly limitless — in this case, its properties (a low level binary format) and platform-agnostic disposition made it an ideal choice for something truly fresh & unique.
                
                The last question that remains, is what will YOU do with it?
            </pre>
        </section>


        <section id=the-end class=no-effect>
            <img src="./assets/" alt="Thank You!" />
            <h2>THANK YOU!</h2>
        </section>

        <section id=resources>
            <ul>
                <li></li>
            </ul>
        </section>
    </main>

    <script src="./effect/effect.js"></script>
</body>
</html>